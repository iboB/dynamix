// DynaMix
// Copyright (c) 2013-2018 Borislav Stanimirov, Zahary Karadjov
//
// Distributed under the MIT Software License
// See accompanying file LICENSE.txt or copy at
// https://opensource.org/licenses/MIT
//
// this file is automatically generated by a script
//


#define _DYNAMIX_MESSAGE0_DECL(export, message_name, method_name, return_type, constness, message_mechanism ) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::_DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism) \
        <_DYNAMIX_MESSAGE_STRUCT_NAME(message_name), constness ::dynamix::object, return_type > \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : _DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism)(_DYNAMIX_PP_STRINGIZE(message_name)) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            /* also use explicit type of method, so it would match the exact overload */ \
            static caller_func the_caller = caller<Mixin, _DYNAMIX_CAST_METHOD((return_type (Mixin::*)() constness)) &Mixin::method_name>; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * _DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define _DYNAMIX_MESSAGE0_UNI(export, message_name, method_name, return_type, constness ) \
    _DYNAMIX_MESSAGE0_DECL(export, message_name, method_name, return_type, constness, unicast ) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj ) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj ); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj ) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj ); \
    }\

#define _DYNAMIX_MESSAGE0_MULTI(export, message_name, method_name, return_type, constness ) \
    _DYNAMIX_MESSAGE0_DECL(export, message_name, method_name, return_type, constness, multicast ) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , Combinator& _d_combinator) \
    { \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator ); \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj ) \
    { \
        Combinator<return_type> _d_combinator; \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator ); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj ) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj ); \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj ) \
    {\
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj ); \
    }\

#define DYNAMIX_MESSAGE_0(return_type, message ) \
    _DYNAMIX_MESSAGE0_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() )

#define DYNAMIX_CONST_MESSAGE_0(return_type, message ) \
    _DYNAMIX_MESSAGE0_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const )

#define DYNAMIX_MULTICAST_MESSAGE_0(return_type, message ) \
    _DYNAMIX_MESSAGE0_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() )

#define DYNAMIX_CONST_MULTICAST_MESSAGE_0(return_type, message ) \
    _DYNAMIX_MESSAGE0_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const )

#define DYNAMIX_EXPORTED_MESSAGE_0(export, return_type, message ) \
    _DYNAMIX_MESSAGE0_UNI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() )

#define DYNAMIX_EXPORTED_CONST_MESSAGE_0(export, return_type, message ) \
    _DYNAMIX_MESSAGE0_UNI(export, message, message, return_type, const )

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_0(export, return_type, message ) \
    _DYNAMIX_MESSAGE0_MULTI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() )

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_0(export, return_type, message ) \
    _DYNAMIX_MESSAGE0_MULTI(export, message, message, return_type, const )

#define DYNAMIX_MESSAGE_0_OVERLOAD(message_name, return_type, method_name ) \
    _DYNAMIX_MESSAGE0_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() )

#define DYNAMIX_CONST_MESSAGE_0_OVERLOAD(message_name, return_type, method_name ) \
    _DYNAMIX_MESSAGE0_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const )

#define DYNAMIX_MULTICAST_MESSAGE_0_OVERLOAD(message_name, return_type, method_name ) \
    _DYNAMIX_MESSAGE0_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() )

#define DYNAMIX_CONST_MULTICAST_MESSAGE_0_OVERLOAD(message_name, return_type, method_name ) \
    _DYNAMIX_MESSAGE0_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const )

#define DYNAMIX_EXPORTED_MESSAGE_0_OVERLOAD(export, message_name, return_type, method_name ) \
    _DYNAMIX_MESSAGE0_UNI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() )

#define DYNAMIX_EXPORTED_CONST_MESSAGE_0_OVERLOAD(export, message_name, return_type, method_name ) \
    _DYNAMIX_MESSAGE0_UNI(export, message_name, method_name, return_type, const )

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_0_OVERLOAD(export, message_name, return_type, method_name ) \
    _DYNAMIX_MESSAGE0_MULTI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() )

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_0_OVERLOAD(export, message_name, return_type, method_name ) \
    _DYNAMIX_MESSAGE0_MULTI(export, message_name, method_name, return_type, const )

#define DYNAMIX_DEFINE_MESSAGE_0_WITH_DEFAULT_IMPL(return_type, message_name ) \
    /* standard message definition */ \
    struct DYNAMIX_DEFAULT_IMPL_STRUCT(message_name) \
    { \
        return_type impl(); \
        static return_type caller(void* self ) \
        { \
            return reinterpret_cast<DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)*>(self)->impl(); \
        } \
    }; \
    /* create feature getters for the message */ \
    ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
    } \
    const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_fast(); \
    } \
    /* create a feature registrator */ \
    void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)& msg = ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
        ::dynamix::internal::domain::safe_instance().register_feature(msg); \
        \
        /* set message default implementation data */ \
        static ::dynamix::internal::message_for_mixin default_impl = { \
            &msg, \
            DYNAMIX_MAX_MIXINS, \
            reinterpret_cast<::dynamix::internal::func_ptr>(&DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::caller), \
            ::std::numeric_limits<int>::min(), \
        }; \
        msg.default_impl_data = &default_impl; \
    } \
    /* provide a tag instance */ \
    _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)* _DYNAMIX_MESSAGE_TAG(message_name); \
    /* instantiate metafunction initializator in case no class registers the message */ \
    inline void _dynamix_register_message(_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        ::dynamix::internal::message_registrator<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::registrator.unused = true; \
    } \
    /* begin default impl function so the used can just enter it after the macro */ \
    return_type DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::impl()

#define _DYNAMIX_MESSAGE1_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::_DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism) \
        <_DYNAMIX_MESSAGE_STRUCT_NAME(message_name), constness ::dynamix::object, return_type , arg0_type> \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : _DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism)(_DYNAMIX_PP_STRINGIZE(message_name)) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            /* also use explicit type of method, so it would match the exact overload */ \
            static caller_func the_caller = caller<Mixin, _DYNAMIX_CAST_METHOD((return_type (Mixin::*)(arg0_type a0) constness)) &Mixin::method_name>; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * _DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define _DYNAMIX_MESSAGE1_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0)); \
    }\

#define _DYNAMIX_MESSAGE1_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, Combinator& _d_combinator) \
    { \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0)); \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0) \
    { \
        Combinator<return_type> _d_combinator; \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0)); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0)); \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0) \
    {\
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0)); \
    }\

#define DYNAMIX_MESSAGE_1(return_type, message , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0)

#define DYNAMIX_CONST_MESSAGE_1(return_type, message , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0)

#define DYNAMIX_MULTICAST_MESSAGE_1(return_type, message , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_1(return_type, message , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0)

#define DYNAMIX_EXPORTED_MESSAGE_1(export, return_type, message , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_UNI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_1(export, return_type, message , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_UNI(export, message, message, return_type, const , arg0_type, a0)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_1(export, return_type, message , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_MULTI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_1(export, return_type, message , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_MULTI(export, message, message, return_type, const , arg0_type, a0)

#define DYNAMIX_MESSAGE_1_OVERLOAD(message_name, return_type, method_name , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0)

#define DYNAMIX_CONST_MESSAGE_1_OVERLOAD(message_name, return_type, method_name , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0)

#define DYNAMIX_MULTICAST_MESSAGE_1_OVERLOAD(message_name, return_type, method_name , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_1_OVERLOAD(message_name, return_type, method_name , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0)

#define DYNAMIX_EXPORTED_MESSAGE_1_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_UNI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_1_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_UNI(export, message_name, method_name, return_type, const , arg0_type, a0)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_1_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_MULTI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_1_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0) \
    _DYNAMIX_MESSAGE1_MULTI(export, message_name, method_name, return_type, const , arg0_type, a0)

#define DYNAMIX_DEFINE_MESSAGE_1_WITH_DEFAULT_IMPL(return_type, message_name , arg0_type, a0) \
    /* standard message definition */ \
    struct DYNAMIX_DEFAULT_IMPL_STRUCT(message_name) \
    { \
        return_type impl(arg0_type a0); \
        static return_type caller(void* self , arg0_type a0) \
        { \
            return reinterpret_cast<DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)*>(self)->impl(std::forward<arg0_type>(a0)); \
        } \
    }; \
    /* create feature getters for the message */ \
    ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
    } \
    const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_fast(); \
    } \
    /* create a feature registrator */ \
    void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)& msg = ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
        ::dynamix::internal::domain::safe_instance().register_feature(msg); \
        \
        /* set message default implementation data */ \
        static ::dynamix::internal::message_for_mixin default_impl = { \
            &msg, \
            DYNAMIX_MAX_MIXINS, \
            reinterpret_cast<::dynamix::internal::func_ptr>(&DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::caller), \
            ::std::numeric_limits<int>::min(), \
        }; \
        msg.default_impl_data = &default_impl; \
    } \
    /* provide a tag instance */ \
    _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)* _DYNAMIX_MESSAGE_TAG(message_name); \
    /* instantiate metafunction initializator in case no class registers the message */ \
    inline void _dynamix_register_message(_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        ::dynamix::internal::message_registrator<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::registrator.unused = true; \
    } \
    /* begin default impl function so the used can just enter it after the macro */ \
    return_type DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::impl(arg0_type a0)

#define _DYNAMIX_MESSAGE2_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0, arg1_type, a1) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::_DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism) \
        <_DYNAMIX_MESSAGE_STRUCT_NAME(message_name), constness ::dynamix::object, return_type , arg0_type, arg1_type> \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : _DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism)(_DYNAMIX_PP_STRINGIZE(message_name)) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            /* also use explicit type of method, so it would match the exact overload */ \
            static caller_func the_caller = caller<Mixin, _DYNAMIX_CAST_METHOD((return_type (Mixin::*)(arg0_type a0, arg1_type a1) constness)) &Mixin::method_name>; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * _DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define _DYNAMIX_MESSAGE2_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0, arg1_type, a1) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1)); \
    }\

#define _DYNAMIX_MESSAGE2_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0, arg1_type, a1) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, Combinator& _d_combinator) \
    { \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1)); \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1) \
    { \
        Combinator<return_type> _d_combinator; \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1)); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1)); \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1) \
    {\
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1)); \
    }\

#define DYNAMIX_MESSAGE_2(return_type, message , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_CONST_MESSAGE_2(return_type, message , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_MULTICAST_MESSAGE_2(return_type, message , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_2(return_type, message , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_EXPORTED_MESSAGE_2(export, return_type, message , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_UNI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_2(export, return_type, message , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_UNI(export, message, message, return_type, const , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_2(export, return_type, message , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_MULTI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_2(export, return_type, message , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_MULTI(export, message, message, return_type, const , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_MESSAGE_2_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_CONST_MESSAGE_2_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_MULTICAST_MESSAGE_2_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_2_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_EXPORTED_MESSAGE_2_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_UNI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_2_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_UNI(export, message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_2_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_MULTI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_2_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1) \
    _DYNAMIX_MESSAGE2_MULTI(export, message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1)

#define DYNAMIX_DEFINE_MESSAGE_2_WITH_DEFAULT_IMPL(return_type, message_name , arg0_type, a0, arg1_type, a1) \
    /* standard message definition */ \
    struct DYNAMIX_DEFAULT_IMPL_STRUCT(message_name) \
    { \
        return_type impl(arg0_type a0, arg1_type a1); \
        static return_type caller(void* self , arg0_type a0, arg1_type a1) \
        { \
            return reinterpret_cast<DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)*>(self)->impl(std::forward<arg0_type>(a0), std::forward<arg1_type>(a1)); \
        } \
    }; \
    /* create feature getters for the message */ \
    ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
    } \
    const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_fast(); \
    } \
    /* create a feature registrator */ \
    void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)& msg = ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
        ::dynamix::internal::domain::safe_instance().register_feature(msg); \
        \
        /* set message default implementation data */ \
        static ::dynamix::internal::message_for_mixin default_impl = { \
            &msg, \
            DYNAMIX_MAX_MIXINS, \
            reinterpret_cast<::dynamix::internal::func_ptr>(&DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::caller), \
            ::std::numeric_limits<int>::min(), \
        }; \
        msg.default_impl_data = &default_impl; \
    } \
    /* provide a tag instance */ \
    _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)* _DYNAMIX_MESSAGE_TAG(message_name); \
    /* instantiate metafunction initializator in case no class registers the message */ \
    inline void _dynamix_register_message(_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        ::dynamix::internal::message_registrator<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::registrator.unused = true; \
    } \
    /* begin default impl function so the used can just enter it after the macro */ \
    return_type DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::impl(arg0_type a0, arg1_type a1)

#define _DYNAMIX_MESSAGE3_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::_DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism) \
        <_DYNAMIX_MESSAGE_STRUCT_NAME(message_name), constness ::dynamix::object, return_type , arg0_type, arg1_type, arg2_type> \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : _DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism)(_DYNAMIX_PP_STRINGIZE(message_name)) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            /* also use explicit type of method, so it would match the exact overload */ \
            static caller_func the_caller = caller<Mixin, _DYNAMIX_CAST_METHOD((return_type (Mixin::*)(arg0_type a0, arg1_type a1, arg2_type a2) constness)) &Mixin::method_name>; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * _DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define _DYNAMIX_MESSAGE3_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2)); \
    }\

#define _DYNAMIX_MESSAGE3_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, Combinator& _d_combinator) \
    { \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2)); \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2) \
    { \
        Combinator<return_type> _d_combinator; \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2)); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2)); \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2) \
    {\
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2)); \
    }\

#define DYNAMIX_MESSAGE_3(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_CONST_MESSAGE_3(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_MULTICAST_MESSAGE_3(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_3(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_EXPORTED_MESSAGE_3(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_UNI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_3(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_UNI(export, message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_3(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_MULTI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_3(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_MULTI(export, message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_MESSAGE_3_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_CONST_MESSAGE_3_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_MULTICAST_MESSAGE_3_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_3_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_EXPORTED_MESSAGE_3_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_UNI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_3_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_UNI(export, message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_3_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_MULTI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_3_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    _DYNAMIX_MESSAGE3_MULTI(export, message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2)

#define DYNAMIX_DEFINE_MESSAGE_3_WITH_DEFAULT_IMPL(return_type, message_name , arg0_type, a0, arg1_type, a1, arg2_type, a2) \
    /* standard message definition */ \
    struct DYNAMIX_DEFAULT_IMPL_STRUCT(message_name) \
    { \
        return_type impl(arg0_type a0, arg1_type a1, arg2_type a2); \
        static return_type caller(void* self , arg0_type a0, arg1_type a1, arg2_type a2) \
        { \
            return reinterpret_cast<DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)*>(self)->impl(std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2)); \
        } \
    }; \
    /* create feature getters for the message */ \
    ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
    } \
    const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_fast(); \
    } \
    /* create a feature registrator */ \
    void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)& msg = ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
        ::dynamix::internal::domain::safe_instance().register_feature(msg); \
        \
        /* set message default implementation data */ \
        static ::dynamix::internal::message_for_mixin default_impl = { \
            &msg, \
            DYNAMIX_MAX_MIXINS, \
            reinterpret_cast<::dynamix::internal::func_ptr>(&DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::caller), \
            ::std::numeric_limits<int>::min(), \
        }; \
        msg.default_impl_data = &default_impl; \
    } \
    /* provide a tag instance */ \
    _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)* _DYNAMIX_MESSAGE_TAG(message_name); \
    /* instantiate metafunction initializator in case no class registers the message */ \
    inline void _dynamix_register_message(_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        ::dynamix::internal::message_registrator<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::registrator.unused = true; \
    } \
    /* begin default impl function so the used can just enter it after the macro */ \
    return_type DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::impl(arg0_type a0, arg1_type a1, arg2_type a2)

#define _DYNAMIX_MESSAGE4_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::_DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism) \
        <_DYNAMIX_MESSAGE_STRUCT_NAME(message_name), constness ::dynamix::object, return_type , arg0_type, arg1_type, arg2_type, arg3_type> \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : _DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism)(_DYNAMIX_PP_STRINGIZE(message_name)) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            /* also use explicit type of method, so it would match the exact overload */ \
            static caller_func the_caller = caller<Mixin, _DYNAMIX_CAST_METHOD((return_type (Mixin::*)(arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) constness)) &Mixin::method_name>; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * _DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define _DYNAMIX_MESSAGE4_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3)); \
    }\

#define _DYNAMIX_MESSAGE4_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, Combinator& _d_combinator) \
    { \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3)); \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) \
    { \
        Combinator<return_type> _d_combinator; \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3)); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3)); \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) \
    {\
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3)); \
    }\

#define DYNAMIX_MESSAGE_4(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_CONST_MESSAGE_4(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_MULTICAST_MESSAGE_4(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_4(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_EXPORTED_MESSAGE_4(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_UNI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_4(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_UNI(export, message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_4(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_MULTI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_4(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_MULTI(export, message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_MESSAGE_4_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_CONST_MESSAGE_4_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_MULTICAST_MESSAGE_4_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_4_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_EXPORTED_MESSAGE_4_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_UNI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_4_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_UNI(export, message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_4_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_MULTI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_4_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    _DYNAMIX_MESSAGE4_MULTI(export, message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3)

#define DYNAMIX_DEFINE_MESSAGE_4_WITH_DEFAULT_IMPL(return_type, message_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3) \
    /* standard message definition */ \
    struct DYNAMIX_DEFAULT_IMPL_STRUCT(message_name) \
    { \
        return_type impl(arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3); \
        static return_type caller(void* self , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3) \
        { \
            return reinterpret_cast<DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)*>(self)->impl(std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3)); \
        } \
    }; \
    /* create feature getters for the message */ \
    ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
    } \
    const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_fast(); \
    } \
    /* create a feature registrator */ \
    void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)& msg = ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
        ::dynamix::internal::domain::safe_instance().register_feature(msg); \
        \
        /* set message default implementation data */ \
        static ::dynamix::internal::message_for_mixin default_impl = { \
            &msg, \
            DYNAMIX_MAX_MIXINS, \
            reinterpret_cast<::dynamix::internal::func_ptr>(&DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::caller), \
            ::std::numeric_limits<int>::min(), \
        }; \
        msg.default_impl_data = &default_impl; \
    } \
    /* provide a tag instance */ \
    _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)* _DYNAMIX_MESSAGE_TAG(message_name); \
    /* instantiate metafunction initializator in case no class registers the message */ \
    inline void _dynamix_register_message(_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        ::dynamix::internal::message_registrator<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::registrator.unused = true; \
    } \
    /* begin default impl function so the used can just enter it after the macro */ \
    return_type DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::impl(arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3)

#define _DYNAMIX_MESSAGE5_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::_DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism) \
        <_DYNAMIX_MESSAGE_STRUCT_NAME(message_name), constness ::dynamix::object, return_type , arg0_type, arg1_type, arg2_type, arg3_type, arg4_type> \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : _DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism)(_DYNAMIX_PP_STRINGIZE(message_name)) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            /* also use explicit type of method, so it would match the exact overload */ \
            static caller_func the_caller = caller<Mixin, _DYNAMIX_CAST_METHOD((return_type (Mixin::*)(arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) constness)) &Mixin::method_name>; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * _DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define _DYNAMIX_MESSAGE5_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4)); \
    }\

#define _DYNAMIX_MESSAGE5_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, Combinator& _d_combinator) \
    { \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4)); \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) \
    { \
        Combinator<return_type> _d_combinator; \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4)); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4)); \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) \
    {\
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4)); \
    }\

#define DYNAMIX_MESSAGE_5(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_CONST_MESSAGE_5(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_MULTICAST_MESSAGE_5(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_5(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_EXPORTED_MESSAGE_5(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_UNI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_5(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_UNI(export, message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_5(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_MULTI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_5(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_MULTI(export, message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_MESSAGE_5_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_CONST_MESSAGE_5_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_MULTICAST_MESSAGE_5_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_5_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_EXPORTED_MESSAGE_5_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_UNI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_5_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_UNI(export, message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_5_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_MULTI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_5_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    _DYNAMIX_MESSAGE5_MULTI(export, message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4)

#define DYNAMIX_DEFINE_MESSAGE_5_WITH_DEFAULT_IMPL(return_type, message_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4) \
    /* standard message definition */ \
    struct DYNAMIX_DEFAULT_IMPL_STRUCT(message_name) \
    { \
        return_type impl(arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4); \
        static return_type caller(void* self , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4) \
        { \
            return reinterpret_cast<DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)*>(self)->impl(std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4)); \
        } \
    }; \
    /* create feature getters for the message */ \
    ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
    } \
    const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_fast(); \
    } \
    /* create a feature registrator */ \
    void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)& msg = ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
        ::dynamix::internal::domain::safe_instance().register_feature(msg); \
        \
        /* set message default implementation data */ \
        static ::dynamix::internal::message_for_mixin default_impl = { \
            &msg, \
            DYNAMIX_MAX_MIXINS, \
            reinterpret_cast<::dynamix::internal::func_ptr>(&DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::caller), \
            ::std::numeric_limits<int>::min(), \
        }; \
        msg.default_impl_data = &default_impl; \
    } \
    /* provide a tag instance */ \
    _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)* _DYNAMIX_MESSAGE_TAG(message_name); \
    /* instantiate metafunction initializator in case no class registers the message */ \
    inline void _dynamix_register_message(_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        ::dynamix::internal::message_registrator<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::registrator.unused = true; \
    } \
    /* begin default impl function so the used can just enter it after the macro */ \
    return_type DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::impl(arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4)

#define _DYNAMIX_MESSAGE6_DECL(export, message_name, method_name, return_type, constness, message_mechanism , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    /* mechanism shows whether it's a multicast or unicast */ \
    \
    /* step 1: define the message struct */ \
    struct export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) : public ::dynamix::internal::_DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism) \
        <_DYNAMIX_MESSAGE_STRUCT_NAME(message_name), constness ::dynamix::object, return_type , arg0_type, arg1_type, arg2_type, arg3_type, arg4_type, arg5_type> \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)() \
            : _DYNAMIX_MESSAGE_CALLER_STRUCT(message_mechanism)(_DYNAMIX_PP_STRINGIZE(message_name)) \
        {} \
        template <typename Mixin> \
        ::dynamix::internal::func_ptr get_caller_for() const \
        { \
            /* prevent the linker from optimizing away the caller function */ \
            /* also use explicit type of method, so it would match the exact overload */ \
            static caller_func the_caller = caller<Mixin, _DYNAMIX_CAST_METHOD((return_type (Mixin::*)(arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) constness)) &Mixin::method_name>; \
            /* cast the caller to a void (*)() - safe according to the standard */ \
            return reinterpret_cast< ::dynamix::internal::func_ptr>(the_caller); \
        } \
    }; \
    /* step 2: define a message tag, that will be used to identify the message in feature lists */ \
    /* it would have been nice if we could set this global variable to the unique global instance of the feature*/ \
    /* but unfortunately we cannot trust dynamic libraries to keep it straight for us */ \
    /* hence we rely on a getter like the mixin one */ \
    extern export _DYNAMIX_MESSAGE_STRUCT_NAME(message_name) * _DYNAMIX_MESSAGE_TAG(message_name); \
    /* step 3: declare the feature getter and manual registrator for the message */ \
    extern export ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \
    extern export void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*); \

#define _DYNAMIX_MESSAGE6_UNI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_DECL(export, message_name, method_name, return_type, constness, unicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    /* step 4: define the message function -> the one that will be called for the objects */ \
    inline return_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4), std::forward<arg5_type>(a5)); \
    }\
    /* also define a pointer function */ \
    inline return_type method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) \
    {\
        return _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4), std::forward<arg5_type>(a5)); \
    }\

#define _DYNAMIX_MESSAGE6_MULTI(export, message_name, method_name, return_type, constness , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_DECL(export, message_name, method_name, return_type, constness, multicast , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    /* step 4: define the message functions -> the one that will be called for the objects */ \
    /* function A: concrete combinator */ \
    template <typename Combinator> \
    void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5, Combinator& _d_combinator) \
    { \
        /* not forwarded arguments. We DO want an error if some of them are rvalue references */ \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4), std::forward<arg5_type>(a5)); \
    } \
    /* function B: template combinator -> can be called on a single line */ \
    template <template <typename> class Combinator> \
    typename Combinator<return_type>::result_type method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) \
    { \
        Combinator<return_type> _d_combinator; \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_combinator_call(_d_obj, _d_combinator , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4), std::forward<arg5_type>(a5)); \
        return _d_combinator.result(); \
    } \
    /* function C: no combinator */ \
    inline void method_name(constness ::dynamix::object& _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4), std::forward<arg5_type>(a5)); \
    } \
    /* also define a pointer function with no combinator */ \
    inline void method_name(constness ::dynamix::object* _d_obj , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) \
    {\
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)::make_call(*_d_obj , std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4), std::forward<arg5_type>(a5)); \
    }\

#define DYNAMIX_MESSAGE_6(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_CONST_MESSAGE_6(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_UNI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_MULTICAST_MESSAGE_6(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_6(return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_MULTI(_DYNAMIX_PP_EMPTY(), message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_EXPORTED_MESSAGE_6(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_UNI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_6(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_UNI(export, message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_6(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_MULTI(export, message, message, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_6(export, return_type, message , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_MULTI(export, message, message, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_MESSAGE_6_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_CONST_MESSAGE_6_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_UNI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_MULTICAST_MESSAGE_6_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_CONST_MULTICAST_MESSAGE_6_OVERLOAD(message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_MULTI(_DYNAMIX_PP_EMPTY(), message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_EXPORTED_MESSAGE_6_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_UNI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_EXPORTED_CONST_MESSAGE_6_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_UNI(export, message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_EXPORTED_MULTICAST_MESSAGE_6_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_MULTI(export, message_name, method_name, return_type, _DYNAMIX_PP_EMPTY() , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_EXPORTED_CONST_MULTICAST_MESSAGE_6_OVERLOAD(export, message_name, return_type, method_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    _DYNAMIX_MESSAGE6_MULTI(export, message_name, method_name, return_type, const , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5)

#define DYNAMIX_DEFINE_MESSAGE_6_WITH_DEFAULT_IMPL(return_type, message_name , arg0_type, a0, arg1_type, a1, arg2_type, a2, arg3_type, a3, arg4_type, a4, arg5_type, a5) \
    /* standard message definition */ \
    struct DYNAMIX_DEFAULT_IMPL_STRUCT(message_name) \
    { \
        return_type impl(arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5); \
        static return_type caller(void* self , arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5) \
        { \
            return reinterpret_cast<DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)*>(self)->impl(std::forward<arg0_type>(a0), std::forward<arg1_type>(a1), std::forward<arg2_type>(a2), std::forward<arg3_type>(a3), std::forward<arg4_type>(a4), std::forward<arg5_type>(a5)); \
        } \
    }; \
    /* create feature getters for the message */ \
    ::dynamix::feature& _dynamix_get_mixin_feature_safe(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
    } \
    const ::dynamix::feature& _dynamix_get_mixin_feature_fast(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        return ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_fast(); \
    } \
    /* create a feature registrator */ \
    void _dynamix_register_mixin_feature(const _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)& msg = ::dynamix::internal::feature_instance<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::the_feature_safe(); \
        ::dynamix::internal::domain::safe_instance().register_feature(msg); \
        \
        /* set message default implementation data */ \
        static ::dynamix::internal::message_for_mixin default_impl = { \
            &msg, \
            DYNAMIX_MAX_MIXINS, \
            reinterpret_cast<::dynamix::internal::func_ptr>(&DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::caller), \
            ::std::numeric_limits<int>::min(), \
        }; \
        msg.default_impl_data = &default_impl; \
    } \
    /* provide a tag instance */ \
    _DYNAMIX_MESSAGE_STRUCT_NAME(message_name)* _DYNAMIX_MESSAGE_TAG(message_name); \
    /* instantiate metafunction initializator in case no class registers the message */ \
    inline void _dynamix_register_message(_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)*) \
    { \
        ::dynamix::internal::message_registrator<_DYNAMIX_MESSAGE_STRUCT_NAME(message_name)>::registrator.unused = true; \
    } \
    /* begin default impl function so the used can just enter it after the macro */ \
    return_type DYNAMIX_DEFAULT_IMPL_STRUCT(message_name)::impl(arg0_type a0, arg1_type a1, arg2_type a2, arg3_type a3, arg4_type a4, arg5_type a5)
